
## ğŸ“ **Emergency Drone Coordination System - Rapor**

### 1. TasarÄ±m KararlarÄ± 

Bu projede temel amacÄ±mÄ±z, bir afet bÃ¶lgesinde kurtarÄ±lmasÄ± gereken kazazedeleri (survivor) otonom droneâ€™larla koordine bir ÅŸekilde bulmak ve yardÄ±m ulaÅŸtÄ±rmak Ã¼zerine bir simÃ¼lasyon gerÃ§ekleÅŸtirmektir. TasarÄ±m sÃ¼recinde aÅŸaÄŸÄ±daki temel kararlar alÄ±nmÄ±ÅŸtÄ±r:

* **ModÃ¼lerlik**: Kod yapÄ±sÄ± `drone`, `survivor`, `ai`, `list`, `view` gibi farklÄ± dosyalara bÃ¶lÃ¼nerek sorumluluklar ayrÄ±lmÄ±ÅŸ ve kodun sÃ¼rdÃ¼rÃ¼lebilirliÄŸi artÄ±rÄ±lmÄ±ÅŸtÄ±r.

* **Ä°ki modlu yapÄ±**:

  * **SimÃ¼lasyon Modu (`main.c`)**: Dronlar, survivorâ€™lar ve yapay zeka aynÄ± proses iÃ§erisinde farklÄ± threadâ€™ler olarak Ã§alÄ±ÅŸÄ±r. SDL ile gÃ¶rsel arayÃ¼z oluÅŸturulmuÅŸtur.
  * **Client-Server Modu (`client.c`, `server.c`)**: GerÃ§ek bir soket baÄŸlantÄ±sÄ± kurularak her drone baÄŸÄ±msÄ±z bir istemci gibi Ã§alÄ±ÅŸÄ±r. Bu mimari, daÄŸÄ±tÄ±k sistemleri test etmeye olanak tanÄ±r.

* **Thread-safe liste**: Survivorâ€™larÄ±n tutulduÄŸu `List` yapÄ±sÄ± mutex ile korunarak Ã§oklu thread eriÅŸimine uygun hale getirilmiÅŸtir.

* **JSON veri formatÄ±**: Drone-server iletiÅŸiminde veri aktarÄ±mÄ± iÃ§in insan tarafÄ±ndan okunabilir ve sistemler arasÄ± uyumlu olan JSON benzeri mesaj yapÄ±larÄ± tercih edilmiÅŸtir.

* **Koordinat tabanlÄ± gÃ¶revler**: Her droneâ€™un hedefi (survivor) belirli bir `(x, y)` koordinatÄ±dÄ±r. GÃ¶rev atamalarÄ± bu koordinatlar Ã¼zerinden yapÄ±lÄ±r.

---

### 2. Senkronizasyon Stratejisi 
Ã‡ok iÅŸ parÃ§acÄ±klÄ± bir yapÄ±da veri tutarlÄ±lÄ±ÄŸÄ± saÄŸlamak iÃ§in senkronizasyon hayati Ã¶nemdedir. Projede kullanÄ±lan senkronizasyon stratejileri ÅŸunlardÄ±r:

#### a. `pthread_mutex_t` kullanÄ±mÄ±:

* `List` yapÄ±sÄ± iÃ§inde (`list.c`) `pthread_mutex_t` ile listeye eriÅŸim senkronize edilmiÅŸtir:

  * `list_add()`, `list_pop()` ve `list_destroy()` fonksiyonlarÄ± mutex ile korunmuÅŸtur.
* Survivorâ€™lar listeye her 2 saniyede bir eklenirken, AI threadâ€™i listeyi tarayarak gÃ¶rev atamasÄ± yapar. Bu eÅŸzamanlÄ± eriÅŸimler mutex ile dÃ¼zenlenmiÅŸtir.

#### b. Drone verilerinde kilitleme:

* Her droneâ€™un (`drone.h`) kendi `pthread_mutex_t lock` deÄŸiÅŸkeni vardÄ±r.
* `drone_behavior()` iÃ§inde konum ve durum gÃ¼ncellenmeden Ã¶nce lock alÄ±nÄ±r.
* AynÄ± ÅŸekilde `mission_assigner()` (AI) gÃ¶rev atarken droneâ€™un verisini korumak iÃ§in Ã¶nce lock alÄ±r.

#### c. GÃ¶rselleÅŸtirme sÄ±rasÄ±nda senkronizasyon:

* `render_scene()` iÃ§inde survivor listesi ve drone verileri okunurken lockâ€™lar alÄ±nÄ±r. BÃ¶ylece render sÄ±rasÄ±nda inconsistent veri okunmaz.

#### d. Client-Server modunda:

* Her drone istemcisi ayrÄ± bir threadâ€™te `server.c` iÃ§inde `handle_drone()` ile karÅŸÄ±lanÄ±r. Socket iletiÅŸiminde thread senkronizasyonundan Ã§ok veri iletimi esastÄ±r. Ancak `write()` ve `read()` fonksiyonlarÄ± kendi iÃ§inde atomik olduÄŸu iÃ§in thread-safe Ã§alÄ±ÅŸÄ±r.

---

### 3. Performans Analizi 

Proje temel olarak dÃ¼ÅŸÃ¼k gecikmeli ve hÄ±zlÄ± tepki veren bir sistem hedeflemektedir. Performans aÃ§Ä±sÄ±ndan deÄŸerlendirme ÅŸu ÅŸekilde yapÄ±labilir:

#### a. **Thread kullanÄ±mÄ± ve Ã¶lÃ§eklenebilirlik:**

* SimÃ¼lasyon modunda her drone, survivor Ã¼retici ve AI ayrÄ± threadâ€™lerde Ã§alÄ±ÅŸÄ±r. BÃ¶ylece paralel Ã§alÄ±ÅŸmaya uygun bir yapÄ± saÄŸlanÄ±r.
* Thread sayÄ±sÄ± arttÄ±kÃ§a performans, Ã§ekirdek sayÄ±sÄ±na baÄŸlÄ± olarak pozitif Ã¶lÃ§eklenebilir.

#### b. **GÃ¶rev atama verimliliÄŸi:**

* `mission_assigner()` her saniyede bir survivor listesine bakar ve uygun dronlara gÃ¶rev atar.
* Atama algoritmasÄ±, boÅŸta olan en yakÄ±n drone'u seÃ§er. Bu da daha kÄ±sa gÃ¶rev sÃ¼releri ve dengeli gÃ¶rev daÄŸÄ±lÄ±mÄ± saÄŸlar.

#### c. **Veri yapÄ±larÄ± ve gecikmeler:**

* Liste yapÄ±sÄ± basit tek yÃ¶nlÃ¼ baÄŸlÄ± liste olduÄŸu iÃ§in `O(n)` tarama sÃ¼resi vardÄ±r. BÃ¼yÃ¼k survivor sayÄ±larÄ±nda bu darboÄŸaz olabilir.
* Mutex kullanÄ±mÄ± nedeniyle liste eriÅŸimi sÄ±rasÄ±nda threadâ€™ler bekleyebilir. Ancak gÃ¶rev atamalarÄ± nadiren yapÄ±ldÄ±ÄŸÄ± iÃ§in bu etki minimumdur.

#### d. **GÃ¶rselleÅŸtirme etkisi:**

* SDL `render_scene()` her 100msâ€™de bir Ã§alÄ±ÅŸÄ±r. Bu sÄ±k gÃ¼ncelleme dÃ¼ÅŸÃ¼k FPS makinelerde gecikmeye neden olabilir. Ancak bu sÃ¼re artÄ±rÄ±larak uyarlanabilir.

#### e. **Client-server gecikmesi:**

* TCP soketleri kullanÄ±ldÄ±ÄŸÄ± iÃ§in aÄŸ Ã¼zerinden Ã§alÄ±ÅŸÄ±rken gÃ¶rev alma/gÃ¶nderme gecikmesi 1-2ms dÃ¼zeyindedir. Gecikme `sleep()` komutlarÄ± ile simÃ¼le edilmiÅŸtir.

---

## ğŸ“Œ SONUÃ‡

Bu proje, hem Ã§ok iÅŸ parÃ§acÄ±klÄ± hem de daÄŸÄ±tÄ±k sistemlere uygun bir yapÄ±yÄ± kÃ¼Ã§Ã¼k Ã¶lÃ§ekte baÅŸarÄ±yla simÃ¼le etmektedir. Senkronizasyon doÄŸru ÅŸekilde uygulanmÄ±ÅŸ ve gÃ¶rev daÄŸÄ±lÄ±mÄ±nda verim saÄŸlanmÄ±ÅŸtÄ±r. KullanÄ±lan yapÄ±lar sayesinde geniÅŸletilebilir ve gerÃ§ek zamanlÄ± senaryolara entegre edilebilir hale gelmiÅŸtir.

